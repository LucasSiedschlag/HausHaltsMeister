// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: budgets.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createBudgetPeriod = `-- name: CreateBudgetPeriod :one
INSERT INTO budget_periods (month, analysis_mode, is_closed)
VALUES ($1, $2, $3)
RETURNING budget_period_id, month, analysis_mode, is_closed
`

type CreateBudgetPeriodParams struct {
	Month        pgtype.Date
	AnalysisMode pgtype.Text
	IsClosed     bool
}

func (q *Queries) CreateBudgetPeriod(ctx context.Context, arg CreateBudgetPeriodParams) (BudgetPeriod, error) {
	row := q.db.QueryRow(ctx, createBudgetPeriod, arg.Month, arg.AnalysisMode, arg.IsClosed)
	var i BudgetPeriod
	err := row.Scan(
		&i.BudgetPeriodID,
		&i.Month,
		&i.AnalysisMode,
		&i.IsClosed,
	)
	return i, err
}

const getBudgetItemsByPeriod = `-- name: GetBudgetItemsByPeriod :many
SELECT 
    bi.budget_item_id, 
    bi.budget_period_id, 
    bi.category_id, 
    bi.mode, 
    bi.planned_amount, 
    bi.target_percent, 
    bi.notes,
    fc.name as category_name
FROM budget_items bi
JOIN flow_categories fc ON fc.category_id = bi.category_id
WHERE bi.budget_period_id = $1
`

type GetBudgetItemsByPeriodRow struct {
	BudgetItemID   int32
	BudgetPeriodID int32
	CategoryID     int32
	Mode           string
	PlannedAmount  pgtype.Numeric
	TargetPercent  pgtype.Numeric
	Notes          pgtype.Text
	CategoryName   string
}

func (q *Queries) GetBudgetItemsByPeriod(ctx context.Context, budgetPeriodID int32) ([]GetBudgetItemsByPeriodRow, error) {
	rows, err := q.db.Query(ctx, getBudgetItemsByPeriod, budgetPeriodID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBudgetItemsByPeriodRow
	for rows.Next() {
		var i GetBudgetItemsByPeriodRow
		if err := rows.Scan(
			&i.BudgetItemID,
			&i.BudgetPeriodID,
			&i.CategoryID,
			&i.Mode,
			&i.PlannedAmount,
			&i.TargetPercent,
			&i.Notes,
			&i.CategoryName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBudgetPeriodByMonth = `-- name: GetBudgetPeriodByMonth :one
SELECT budget_period_id, month, analysis_mode, is_closed
FROM budget_periods
WHERE month = $1
`

func (q *Queries) GetBudgetPeriodByMonth(ctx context.Context, month pgtype.Date) (BudgetPeriod, error) {
	row := q.db.QueryRow(ctx, getBudgetPeriodByMonth, month)
	var i BudgetPeriod
	err := row.Scan(
		&i.BudgetPeriodID,
		&i.Month,
		&i.AnalysisMode,
		&i.IsClosed,
	)
	return i, err
}

const upsertBudgetItem = `-- name: UpsertBudgetItem :one
INSERT INTO budget_items (budget_period_id, category_id, mode, planned_amount, target_percent, notes)
VALUES ($1, $2, $3, $4, $5, $6)
ON CONFLICT (budget_period_id, category_id) DO UPDATE -- Need unique constraint first!
SET mode = EXCLUDED.mode,
    planned_amount = EXCLUDED.planned_amount,
    target_percent = EXCLUDED.target_percent,
    notes = EXCLUDED.notes
RETURNING budget_item_id, budget_period_id, category_id, mode, planned_amount, target_percent, notes
`

type UpsertBudgetItemParams struct {
	BudgetPeriodID int32
	CategoryID     int32
	Mode           string
	PlannedAmount  pgtype.Numeric
	TargetPercent  pgtype.Numeric
	Notes          pgtype.Text
}

func (q *Queries) UpsertBudgetItem(ctx context.Context, arg UpsertBudgetItemParams) (BudgetItem, error) {
	row := q.db.QueryRow(ctx, upsertBudgetItem,
		arg.BudgetPeriodID,
		arg.CategoryID,
		arg.Mode,
		arg.PlannedAmount,
		arg.TargetPercent,
		arg.Notes,
	)
	var i BudgetItem
	err := row.Scan(
		&i.BudgetItemID,
		&i.BudgetPeriodID,
		&i.CategoryID,
		&i.Mode,
		&i.PlannedAmount,
		&i.TargetPercent,
		&i.Notes,
	)
	return i, err
}
