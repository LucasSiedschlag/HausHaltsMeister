// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: picuinhas.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countCasesByPerson = `-- name: CountCasesByPerson :one
SELECT COUNT(*)
FROM installment_plans
WHERE person_id = $1
`

func (q *Queries) CountCasesByPerson(ctx context.Context, personID pgtype.Int4) (int64, error) {
	row := q.db.QueryRow(ctx, countCasesByPerson, personID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createPerson = `-- name: CreatePerson :one
INSERT INTO picuinha_persons (name, notes)
VALUES ($1, $2)
RETURNING person_id, name, notes
`

type CreatePersonParams struct {
	Name  string
	Notes pgtype.Text
}

func (q *Queries) CreatePerson(ctx context.Context, arg CreatePersonParams) (PicuinhaPerson, error) {
	row := q.db.QueryRow(ctx, createPerson, arg.Name, arg.Notes)
	var i PicuinhaPerson
	err := row.Scan(&i.PersonID, &i.Name, &i.Notes)
	return i, err
}

const createPicuinhaCase = `-- name: CreatePicuinhaCase :one
INSERT INTO installment_plans (
  person_id,
  description,
  plan_type,
  total_amount,
  installment_count,
  installment_amount,
  start_date,
  payment_method_id,
  category_id,
  interest_rate,
  interest_rate_unit,
  recurrence_interval_months
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
RETURNING installment_plan_id, description, total_amount, installment_count, installment_amount,
  start_date, payment_method_id, starts_on_current_invoice, plan_type, person_id,
  category_id, interest_rate, interest_rate_unit, recurrence_interval_months, created_at
`

type CreatePicuinhaCaseParams struct {
	PersonID                 pgtype.Int4
	Description              string
	PlanType                 string
	TotalAmount              pgtype.Numeric
	InstallmentCount         int32
	InstallmentAmount        pgtype.Numeric
	StartDate                pgtype.Date
	PaymentMethodID          pgtype.Int4
	CategoryID               pgtype.Int4
	InterestRate             pgtype.Numeric
	InterestRateUnit         pgtype.Text
	RecurrenceIntervalMonths pgtype.Int4
}

func (q *Queries) CreatePicuinhaCase(ctx context.Context, arg CreatePicuinhaCaseParams) (InstallmentPlan, error) {
	row := q.db.QueryRow(ctx, createPicuinhaCase,
		arg.PersonID,
		arg.Description,
		arg.PlanType,
		arg.TotalAmount,
		arg.InstallmentCount,
		arg.InstallmentAmount,
		arg.StartDate,
		arg.PaymentMethodID,
		arg.CategoryID,
		arg.InterestRate,
		arg.InterestRateUnit,
		arg.RecurrenceIntervalMonths,
	)
	var i InstallmentPlan
	err := row.Scan(
		&i.InstallmentPlanID,
		&i.Description,
		&i.TotalAmount,
		&i.InstallmentCount,
		&i.InstallmentAmount,
		&i.StartDate,
		&i.PaymentMethodID,
		&i.StartsOnCurrentInvoice,
		&i.PlanType,
		&i.PersonID,
		&i.CategoryID,
		&i.InterestRate,
		&i.InterestRateUnit,
		&i.RecurrenceIntervalMonths,
		&i.CreatedAt,
	)
	return i, err
}

const createPicuinhaCaseInstallment = `-- name: CreatePicuinhaCaseInstallment :one
INSERT INTO installment_plan_items (
  installment_plan_id,
  installment_number,
  due_date,
  amount,
  extra_amount,
  is_paid,
  paid_at
)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING installment_plan_item_id, installment_plan_id, installment_number, due_date,
  amount, extra_amount, is_paid, paid_at, cash_flow_id
`

type CreatePicuinhaCaseInstallmentParams struct {
	InstallmentPlanID int32
	InstallmentNumber int32
	DueDate           pgtype.Date
	Amount            pgtype.Numeric
	ExtraAmount       pgtype.Numeric
	IsPaid            bool
	PaidAt            pgtype.Timestamp
}

func (q *Queries) CreatePicuinhaCaseInstallment(ctx context.Context, arg CreatePicuinhaCaseInstallmentParams) (InstallmentPlanItem, error) {
	row := q.db.QueryRow(ctx, createPicuinhaCaseInstallment,
		arg.InstallmentPlanID,
		arg.InstallmentNumber,
		arg.DueDate,
		arg.Amount,
		arg.ExtraAmount,
		arg.IsPaid,
		arg.PaidAt,
	)
	var i InstallmentPlanItem
	err := row.Scan(
		&i.InstallmentPlanItemID,
		&i.InstallmentPlanID,
		&i.InstallmentNumber,
		&i.DueDate,
		&i.Amount,
		&i.ExtraAmount,
		&i.IsPaid,
		&i.PaidAt,
		&i.CashFlowID,
	)
	return i, err
}

const deletePerson = `-- name: DeletePerson :exec
DELETE FROM picuinha_persons
WHERE person_id = $1
`

func (q *Queries) DeletePerson(ctx context.Context, personID int32) error {
	_, err := q.db.Exec(ctx, deletePerson, personID)
	return err
}

const deletePicuinhaCase = `-- name: DeletePicuinhaCase :exec
DELETE FROM installment_plans
WHERE installment_plan_id = $1
`

func (q *Queries) DeletePicuinhaCase(ctx context.Context, installmentPlanID int32) error {
	_, err := q.db.Exec(ctx, deletePicuinhaCase, installmentPlanID)
	return err
}

const getPerson = `-- name: GetPerson :one
SELECT person_id, name, notes
FROM picuinha_persons
WHERE person_id = $1
`

func (q *Queries) GetPerson(ctx context.Context, personID int32) (PicuinhaPerson, error) {
	row := q.db.QueryRow(ctx, getPerson, personID)
	var i PicuinhaPerson
	err := row.Scan(&i.PersonID, &i.Name, &i.Notes)
	return i, err
}

const getPersonBalance = `-- name: GetPersonBalance :one
SELECT (
  COALESCE(
    (
      SELECT SUM(i.amount + i.extra_amount)
      FROM installment_plan_items i
      JOIN installment_plans p ON p.installment_plan_id = i.installment_plan_id
      WHERE p.person_id = $1
        AND i.is_paid = false
        AND (
          p.plan_type <> 'RECURRING'
          OR DATE_TRUNC('month', i.due_date) <= DATE_TRUNC('month', CURRENT_DATE)
        )
    ),
    0
  )
)::decimal
`

func (q *Queries) GetPersonBalance(ctx context.Context, personID pgtype.Int4) (pgtype.Numeric, error) {
	row := q.db.QueryRow(ctx, getPersonBalance, personID)
	var column_1 pgtype.Numeric
	err := row.Scan(&column_1)
	return column_1, err
}

const getPicuinhaCase = `-- name: GetPicuinhaCase :one
SELECT installment_plan_id, description, total_amount, installment_count, installment_amount,
  start_date, payment_method_id, starts_on_current_invoice, plan_type, person_id,
  category_id, interest_rate, interest_rate_unit, recurrence_interval_months, created_at
FROM installment_plans
WHERE installment_plan_id = $1
  AND person_id IS NOT NULL
`

func (q *Queries) GetPicuinhaCase(ctx context.Context, installmentPlanID int32) (InstallmentPlan, error) {
	row := q.db.QueryRow(ctx, getPicuinhaCase, installmentPlanID)
	var i InstallmentPlan
	err := row.Scan(
		&i.InstallmentPlanID,
		&i.Description,
		&i.TotalAmount,
		&i.InstallmentCount,
		&i.InstallmentAmount,
		&i.StartDate,
		&i.PaymentMethodID,
		&i.StartsOnCurrentInvoice,
		&i.PlanType,
		&i.PersonID,
		&i.CategoryID,
		&i.InterestRate,
		&i.InterestRateUnit,
		&i.RecurrenceIntervalMonths,
		&i.CreatedAt,
	)
	return i, err
}

const getPicuinhaCaseInstallment = `-- name: GetPicuinhaCaseInstallment :one
SELECT installment_plan_item_id, installment_plan_id, installment_number, due_date,
  amount, extra_amount, is_paid, paid_at, cash_flow_id
FROM installment_plan_items
WHERE installment_plan_item_id = $1
`

func (q *Queries) GetPicuinhaCaseInstallment(ctx context.Context, installmentPlanItemID int32) (InstallmentPlanItem, error) {
	row := q.db.QueryRow(ctx, getPicuinhaCaseInstallment, installmentPlanItemID)
	var i InstallmentPlanItem
	err := row.Scan(
		&i.InstallmentPlanItemID,
		&i.InstallmentPlanID,
		&i.InstallmentNumber,
		&i.DueDate,
		&i.Amount,
		&i.ExtraAmount,
		&i.IsPaid,
		&i.PaidAt,
		&i.CashFlowID,
	)
	return i, err
}

const listPersons = `-- name: ListPersons :many
SELECT person_id, name, notes
FROM picuinha_persons
ORDER BY name
`

func (q *Queries) ListPersons(ctx context.Context) ([]PicuinhaPerson, error) {
	rows, err := q.db.Query(ctx, listPersons)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PicuinhaPerson
	for rows.Next() {
		var i PicuinhaPerson
		if err := rows.Scan(&i.PersonID, &i.Name, &i.Notes); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPicuinhaCaseInstallments = `-- name: ListPicuinhaCaseInstallments :many
SELECT installment_plan_item_id, installment_plan_id, installment_number, due_date,
  amount, extra_amount, is_paid, paid_at, cash_flow_id
FROM installment_plan_items
WHERE installment_plan_id = $1
ORDER BY due_date ASC, installment_number ASC
`

func (q *Queries) ListPicuinhaCaseInstallments(ctx context.Context, installmentPlanID int32) ([]InstallmentPlanItem, error) {
	rows, err := q.db.Query(ctx, listPicuinhaCaseInstallments, installmentPlanID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []InstallmentPlanItem
	for rows.Next() {
		var i InstallmentPlanItem
		if err := rows.Scan(
			&i.InstallmentPlanItemID,
			&i.InstallmentPlanID,
			&i.InstallmentNumber,
			&i.DueDate,
			&i.Amount,
			&i.ExtraAmount,
			&i.IsPaid,
			&i.PaidAt,
			&i.CashFlowID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPicuinhaCasesByPerson = `-- name: ListPicuinhaCasesByPerson :many
SELECT
  p.installment_plan_id,
  p.person_id,
  p.description,
  p.plan_type,
  p.total_amount,
  p.installment_count,
  p.installment_amount,
  p.start_date,
  p.payment_method_id,
  p.category_id,
  p.interest_rate,
  p.interest_rate_unit,
  p.recurrence_interval_months,
  p.created_at,
  COUNT(i.installment_plan_item_id) AS installments_total,
  COUNT(i.installment_plan_item_id) FILTER (WHERE i.is_paid) AS installments_paid,
  COALESCE(SUM(i.amount + i.extra_amount) FILTER (WHERE i.is_paid), 0)::decimal AS amount_paid,
  COALESCE(SUM(i.amount + i.extra_amount) FILTER (WHERE NOT i.is_paid), 0)::decimal AS amount_remaining
FROM installment_plans p
LEFT JOIN installment_plan_items i ON i.installment_plan_id = p.installment_plan_id
WHERE p.person_id = $1
GROUP BY p.installment_plan_id
ORDER BY p.created_at DESC
`

type ListPicuinhaCasesByPersonRow struct {
	InstallmentPlanID        int32
	PersonID                 pgtype.Int4
	Description              string
	PlanType                 string
	TotalAmount              pgtype.Numeric
	InstallmentCount         int32
	InstallmentAmount        pgtype.Numeric
	StartDate                pgtype.Date
	PaymentMethodID          pgtype.Int4
	CategoryID               pgtype.Int4
	InterestRate             pgtype.Numeric
	InterestRateUnit         pgtype.Text
	RecurrenceIntervalMonths pgtype.Int4
	CreatedAt                pgtype.Timestamp
	InstallmentsTotal        int64
	InstallmentsPaid         int64
	AmountPaid               pgtype.Numeric
	AmountRemaining          pgtype.Numeric
}

func (q *Queries) ListPicuinhaCasesByPerson(ctx context.Context, personID pgtype.Int4) ([]ListPicuinhaCasesByPersonRow, error) {
	rows, err := q.db.Query(ctx, listPicuinhaCasesByPerson, personID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPicuinhaCasesByPersonRow
	for rows.Next() {
		var i ListPicuinhaCasesByPersonRow
		if err := rows.Scan(
			&i.InstallmentPlanID,
			&i.PersonID,
			&i.Description,
			&i.PlanType,
			&i.TotalAmount,
			&i.InstallmentCount,
			&i.InstallmentAmount,
			&i.StartDate,
			&i.PaymentMethodID,
			&i.CategoryID,
			&i.InterestRate,
			&i.InterestRateUnit,
			&i.RecurrenceIntervalMonths,
			&i.CreatedAt,
			&i.InstallmentsTotal,
			&i.InstallmentsPaid,
			&i.AmountPaid,
			&i.AmountRemaining,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePerson = `-- name: UpdatePerson :one
UPDATE picuinha_persons
SET name = $2,
    notes = $3
WHERE person_id = $1
RETURNING person_id, name, notes
`

type UpdatePersonParams struct {
	PersonID int32
	Name     string
	Notes    pgtype.Text
}

func (q *Queries) UpdatePerson(ctx context.Context, arg UpdatePersonParams) (PicuinhaPerson, error) {
	row := q.db.QueryRow(ctx, updatePerson, arg.PersonID, arg.Name, arg.Notes)
	var i PicuinhaPerson
	err := row.Scan(&i.PersonID, &i.Name, &i.Notes)
	return i, err
}

const updatePicuinhaCase = `-- name: UpdatePicuinhaCase :one
UPDATE installment_plans
SET person_id = $2,
    description = $3,
    plan_type = $4,
    total_amount = $5,
    installment_count = $6,
    installment_amount = $7,
    start_date = $8,
    payment_method_id = $9,
    category_id = $10,
    interest_rate = $11,
    interest_rate_unit = $12,
    recurrence_interval_months = $13
WHERE installment_plan_id = $1
RETURNING installment_plan_id, description, total_amount, installment_count, installment_amount,
  start_date, payment_method_id, starts_on_current_invoice, plan_type, person_id,
  category_id, interest_rate, interest_rate_unit, recurrence_interval_months, created_at
`

type UpdatePicuinhaCaseParams struct {
	InstallmentPlanID        int32
	PersonID                 pgtype.Int4
	Description              string
	PlanType                 string
	TotalAmount              pgtype.Numeric
	InstallmentCount         int32
	InstallmentAmount        pgtype.Numeric
	StartDate                pgtype.Date
	PaymentMethodID          pgtype.Int4
	CategoryID               pgtype.Int4
	InterestRate             pgtype.Numeric
	InterestRateUnit         pgtype.Text
	RecurrenceIntervalMonths pgtype.Int4
}

func (q *Queries) UpdatePicuinhaCase(ctx context.Context, arg UpdatePicuinhaCaseParams) (InstallmentPlan, error) {
	row := q.db.QueryRow(ctx, updatePicuinhaCase,
		arg.InstallmentPlanID,
		arg.PersonID,
		arg.Description,
		arg.PlanType,
		arg.TotalAmount,
		arg.InstallmentCount,
		arg.InstallmentAmount,
		arg.StartDate,
		arg.PaymentMethodID,
		arg.CategoryID,
		arg.InterestRate,
		arg.InterestRateUnit,
		arg.RecurrenceIntervalMonths,
	)
	var i InstallmentPlan
	err := row.Scan(
		&i.InstallmentPlanID,
		&i.Description,
		&i.TotalAmount,
		&i.InstallmentCount,
		&i.InstallmentAmount,
		&i.StartDate,
		&i.PaymentMethodID,
		&i.StartsOnCurrentInvoice,
		&i.PlanType,
		&i.PersonID,
		&i.CategoryID,
		&i.InterestRate,
		&i.InterestRateUnit,
		&i.RecurrenceIntervalMonths,
		&i.CreatedAt,
	)
	return i, err
}

const updatePicuinhaCaseInstallment = `-- name: UpdatePicuinhaCaseInstallment :one
UPDATE installment_plan_items
SET amount = $2,
    extra_amount = $3,
    is_paid = $4,
    paid_at = $5
WHERE installment_plan_item_id = $1
RETURNING installment_plan_item_id, installment_plan_id, installment_number, due_date,
  amount, extra_amount, is_paid, paid_at, cash_flow_id
`

type UpdatePicuinhaCaseInstallmentParams struct {
	InstallmentPlanItemID int32
	Amount                pgtype.Numeric
	ExtraAmount           pgtype.Numeric
	IsPaid                bool
	PaidAt                pgtype.Timestamp
}

func (q *Queries) UpdatePicuinhaCaseInstallment(ctx context.Context, arg UpdatePicuinhaCaseInstallmentParams) (InstallmentPlanItem, error) {
	row := q.db.QueryRow(ctx, updatePicuinhaCaseInstallment,
		arg.InstallmentPlanItemID,
		arg.Amount,
		arg.ExtraAmount,
		arg.IsPaid,
		arg.PaidAt,
	)
	var i InstallmentPlanItem
	err := row.Scan(
		&i.InstallmentPlanItemID,
		&i.InstallmentPlanID,
		&i.InstallmentNumber,
		&i.DueDate,
		&i.Amount,
		&i.ExtraAmount,
		&i.IsPaid,
		&i.PaidAt,
		&i.CashFlowID,
	)
	return i, err
}
