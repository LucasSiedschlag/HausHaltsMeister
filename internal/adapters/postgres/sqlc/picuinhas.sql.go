// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: picuinhas.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countCasesByPerson = `-- name: CountCasesByPerson :one
SELECT COUNT(*)
FROM picuinha_cases
WHERE person_id = $1
`

func (q *Queries) CountCasesByPerson(ctx context.Context, personID int32) (int64, error) {
	row := q.db.QueryRow(ctx, countCasesByPerson, personID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countEntriesByPerson = `-- name: CountEntriesByPerson :one
SELECT COUNT(*)
FROM picuinha_entries
WHERE person_id = $1
`

func (q *Queries) CountEntriesByPerson(ctx context.Context, personID int32) (int64, error) {
	row := q.db.QueryRow(ctx, countEntriesByPerson, personID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createPerson = `-- name: CreatePerson :one
INSERT INTO picuinha_persons (name, notes)
VALUES ($1, $2)
RETURNING person_id, name, notes
`

type CreatePersonParams struct {
	Name  string
	Notes pgtype.Text
}

func (q *Queries) CreatePerson(ctx context.Context, arg CreatePersonParams) (PicuinhaPerson, error) {
	row := q.db.QueryRow(ctx, createPerson, arg.Name, arg.Notes)
	var i PicuinhaPerson
	err := row.Scan(&i.PersonID, &i.Name, &i.Notes)
	return i, err
}

const createPicuinhaCase = `-- name: CreatePicuinhaCase :one
INSERT INTO picuinha_cases (
  person_id,
  title,
  case_type,
  total_amount,
  installment_count,
  installment_amount,
  start_date,
  payment_method_id,
  installment_plan_id,
  category_id,
  interest_rate,
  interest_rate_unit,
  recurrence_interval_months
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
RETURNING picuinha_case_id, person_id, title, case_type, total_amount, installment_count, installment_amount,
  start_date, payment_method_id, installment_plan_id, category_id, interest_rate, interest_rate_unit,
  recurrence_interval_months, created_at
`

type CreatePicuinhaCaseParams struct {
	PersonID                 int32
	Title                    string
	CaseType                 string
	TotalAmount              pgtype.Numeric
	InstallmentCount         pgtype.Int4
	InstallmentAmount        pgtype.Numeric
	StartDate                pgtype.Date
	PaymentMethodID          pgtype.Int4
	InstallmentPlanID        pgtype.Int4
	CategoryID               pgtype.Int4
	InterestRate             pgtype.Numeric
	InterestRateUnit         pgtype.Text
	RecurrenceIntervalMonths pgtype.Int4
}

func (q *Queries) CreatePicuinhaCase(ctx context.Context, arg CreatePicuinhaCaseParams) (PicuinhaCase, error) {
	row := q.db.QueryRow(ctx, createPicuinhaCase,
		arg.PersonID,
		arg.Title,
		arg.CaseType,
		arg.TotalAmount,
		arg.InstallmentCount,
		arg.InstallmentAmount,
		arg.StartDate,
		arg.PaymentMethodID,
		arg.InstallmentPlanID,
		arg.CategoryID,
		arg.InterestRate,
		arg.InterestRateUnit,
		arg.RecurrenceIntervalMonths,
	)
	var i PicuinhaCase
	err := row.Scan(
		&i.PicuinhaCaseID,
		&i.PersonID,
		&i.Title,
		&i.CaseType,
		&i.TotalAmount,
		&i.InstallmentCount,
		&i.InstallmentAmount,
		&i.StartDate,
		&i.PaymentMethodID,
		&i.InstallmentPlanID,
		&i.CategoryID,
		&i.InterestRate,
		&i.InterestRateUnit,
		&i.RecurrenceIntervalMonths,
		&i.CreatedAt,
	)
	return i, err
}

const createPicuinhaCaseInstallment = `-- name: CreatePicuinhaCaseInstallment :one
INSERT INTO picuinha_case_installments (
  picuinha_case_id,
  installment_number,
  due_date,
  amount,
  extra_amount,
  is_paid,
  paid_at
)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING picuinha_case_installment_id, picuinha_case_id, installment_number, due_date,
  amount, extra_amount, is_paid, paid_at
`

type CreatePicuinhaCaseInstallmentParams struct {
	PicuinhaCaseID    int32
	InstallmentNumber int32
	DueDate           pgtype.Date
	Amount            pgtype.Numeric
	ExtraAmount       pgtype.Numeric
	IsPaid            bool
	PaidAt            pgtype.Timestamp
}

func (q *Queries) CreatePicuinhaCaseInstallment(ctx context.Context, arg CreatePicuinhaCaseInstallmentParams) (PicuinhaCaseInstallment, error) {
	row := q.db.QueryRow(ctx, createPicuinhaCaseInstallment,
		arg.PicuinhaCaseID,
		arg.InstallmentNumber,
		arg.DueDate,
		arg.Amount,
		arg.ExtraAmount,
		arg.IsPaid,
		arg.PaidAt,
	)
	var i PicuinhaCaseInstallment
	err := row.Scan(
		&i.PicuinhaCaseInstallmentID,
		&i.PicuinhaCaseID,
		&i.InstallmentNumber,
		&i.DueDate,
		&i.Amount,
		&i.ExtraAmount,
		&i.IsPaid,
		&i.PaidAt,
	)
	return i, err
}

const createPicuinhaEntry = `-- name: CreatePicuinhaEntry :one
INSERT INTO picuinha_entries (person_id, date, kind, amount, cash_flow_id, payment_method_id, card_owner)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING picuinha_entry_id, person_id, date, kind, amount, cash_flow_id, payment_method_id, card_owner
`

type CreatePicuinhaEntryParams struct {
	PersonID        int32
	Date            pgtype.Date
	Kind            string
	Amount          pgtype.Numeric
	CashFlowID      pgtype.Int4
	PaymentMethodID pgtype.Int4
	CardOwner       string
}

func (q *Queries) CreatePicuinhaEntry(ctx context.Context, arg CreatePicuinhaEntryParams) (PicuinhaEntry, error) {
	row := q.db.QueryRow(ctx, createPicuinhaEntry,
		arg.PersonID,
		arg.Date,
		arg.Kind,
		arg.Amount,
		arg.CashFlowID,
		arg.PaymentMethodID,
		arg.CardOwner,
	)
	var i PicuinhaEntry
	err := row.Scan(
		&i.PicuinhaEntryID,
		&i.PersonID,
		&i.Date,
		&i.Kind,
		&i.Amount,
		&i.CashFlowID,
		&i.PaymentMethodID,
		&i.CardOwner,
	)
	return i, err
}

const deletePerson = `-- name: DeletePerson :exec
DELETE FROM picuinha_persons
WHERE person_id = $1
`

func (q *Queries) DeletePerson(ctx context.Context, personID int32) error {
	_, err := q.db.Exec(ctx, deletePerson, personID)
	return err
}

const deletePicuinhaCase = `-- name: DeletePicuinhaCase :exec
DELETE FROM picuinha_cases
WHERE picuinha_case_id = $1
`

func (q *Queries) DeletePicuinhaCase(ctx context.Context, picuinhaCaseID int32) error {
	_, err := q.db.Exec(ctx, deletePicuinhaCase, picuinhaCaseID)
	return err
}

const deletePicuinhaEntry = `-- name: DeletePicuinhaEntry :exec
DELETE FROM picuinha_entries
WHERE picuinha_entry_id = $1
`

func (q *Queries) DeletePicuinhaEntry(ctx context.Context, picuinhaEntryID int32) error {
	_, err := q.db.Exec(ctx, deletePicuinhaEntry, picuinhaEntryID)
	return err
}

const getEntry = `-- name: GetEntry :one
SELECT picuinha_entry_id, person_id, date, kind, amount, cash_flow_id, payment_method_id, card_owner
FROM picuinha_entries
WHERE picuinha_entry_id = $1
`

func (q *Queries) GetEntry(ctx context.Context, picuinhaEntryID int32) (PicuinhaEntry, error) {
	row := q.db.QueryRow(ctx, getEntry, picuinhaEntryID)
	var i PicuinhaEntry
	err := row.Scan(
		&i.PicuinhaEntryID,
		&i.PersonID,
		&i.Date,
		&i.Kind,
		&i.Amount,
		&i.CashFlowID,
		&i.PaymentMethodID,
		&i.CardOwner,
	)
	return i, err
}

const getPerson = `-- name: GetPerson :one
SELECT person_id, name, notes
FROM picuinha_persons
WHERE person_id = $1
`

func (q *Queries) GetPerson(ctx context.Context, personID int32) (PicuinhaPerson, error) {
	row := q.db.QueryRow(ctx, getPerson, personID)
	var i PicuinhaPerson
	err := row.Scan(&i.PersonID, &i.Name, &i.Notes)
	return i, err
}

const getPersonBalance = `-- name: GetPersonBalance :one
SELECT (
  COALESCE(
    (
      SELECT SUM(CASE WHEN kind = 'PLUS' THEN amount ELSE -amount END)
      FROM picuinha_entries pe
      WHERE pe.person_id = $1
    ),
    0
  )
  +
  COALESCE(
    (
      SELECT SUM(i.amount + i.extra_amount)
      FROM picuinha_case_installments i
      JOIN picuinha_cases c ON c.picuinha_case_id = i.picuinha_case_id
      WHERE c.person_id = $1
        AND i.is_paid = false
        AND (
          c.case_type <> 'RECURRING'
          OR DATE_TRUNC('month', i.due_date) <= DATE_TRUNC('month', CURRENT_DATE)
        )
    ),
    0
  )
)::decimal
`

func (q *Queries) GetPersonBalance(ctx context.Context, personID int32) (pgtype.Numeric, error) {
	row := q.db.QueryRow(ctx, getPersonBalance, personID)
	var column_1 pgtype.Numeric
	err := row.Scan(&column_1)
	return column_1, err
}

const getPicuinhaCase = `-- name: GetPicuinhaCase :one
SELECT picuinha_case_id, person_id, title, case_type, total_amount, installment_count, installment_amount,
  start_date, payment_method_id, installment_plan_id, category_id, interest_rate, interest_rate_unit,
  recurrence_interval_months, created_at
FROM picuinha_cases
WHERE picuinha_case_id = $1
`

func (q *Queries) GetPicuinhaCase(ctx context.Context, picuinhaCaseID int32) (PicuinhaCase, error) {
	row := q.db.QueryRow(ctx, getPicuinhaCase, picuinhaCaseID)
	var i PicuinhaCase
	err := row.Scan(
		&i.PicuinhaCaseID,
		&i.PersonID,
		&i.Title,
		&i.CaseType,
		&i.TotalAmount,
		&i.InstallmentCount,
		&i.InstallmentAmount,
		&i.StartDate,
		&i.PaymentMethodID,
		&i.InstallmentPlanID,
		&i.CategoryID,
		&i.InterestRate,
		&i.InterestRateUnit,
		&i.RecurrenceIntervalMonths,
		&i.CreatedAt,
	)
	return i, err
}

const getPicuinhaCaseInstallment = `-- name: GetPicuinhaCaseInstallment :one
SELECT picuinha_case_installment_id, picuinha_case_id, installment_number, due_date,
  amount, extra_amount, is_paid, paid_at
FROM picuinha_case_installments
WHERE picuinha_case_installment_id = $1
`

func (q *Queries) GetPicuinhaCaseInstallment(ctx context.Context, picuinhaCaseInstallmentID int32) (PicuinhaCaseInstallment, error) {
	row := q.db.QueryRow(ctx, getPicuinhaCaseInstallment, picuinhaCaseInstallmentID)
	var i PicuinhaCaseInstallment
	err := row.Scan(
		&i.PicuinhaCaseInstallmentID,
		&i.PicuinhaCaseID,
		&i.InstallmentNumber,
		&i.DueDate,
		&i.Amount,
		&i.ExtraAmount,
		&i.IsPaid,
		&i.PaidAt,
	)
	return i, err
}

const listEntries = `-- name: ListEntries :many
SELECT picuinha_entry_id, person_id, date, kind, amount, cash_flow_id, payment_method_id, card_owner
FROM picuinha_entries
ORDER BY date DESC
`

func (q *Queries) ListEntries(ctx context.Context) ([]PicuinhaEntry, error) {
	rows, err := q.db.Query(ctx, listEntries)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PicuinhaEntry
	for rows.Next() {
		var i PicuinhaEntry
		if err := rows.Scan(
			&i.PicuinhaEntryID,
			&i.PersonID,
			&i.Date,
			&i.Kind,
			&i.Amount,
			&i.CashFlowID,
			&i.PaymentMethodID,
			&i.CardOwner,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEntriesByPerson = `-- name: ListEntriesByPerson :many
SELECT picuinha_entry_id, person_id, date, kind, amount, cash_flow_id, payment_method_id, card_owner
FROM picuinha_entries
WHERE person_id = $1
ORDER BY date DESC
`

func (q *Queries) ListEntriesByPerson(ctx context.Context, personID int32) ([]PicuinhaEntry, error) {
	rows, err := q.db.Query(ctx, listEntriesByPerson, personID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PicuinhaEntry
	for rows.Next() {
		var i PicuinhaEntry
		if err := rows.Scan(
			&i.PicuinhaEntryID,
			&i.PersonID,
			&i.Date,
			&i.Kind,
			&i.Amount,
			&i.CashFlowID,
			&i.PaymentMethodID,
			&i.CardOwner,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPersons = `-- name: ListPersons :many
SELECT person_id, name, notes
FROM picuinha_persons
ORDER BY name
`

func (q *Queries) ListPersons(ctx context.Context) ([]PicuinhaPerson, error) {
	rows, err := q.db.Query(ctx, listPersons)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PicuinhaPerson
	for rows.Next() {
		var i PicuinhaPerson
		if err := rows.Scan(&i.PersonID, &i.Name, &i.Notes); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPicuinhaCaseInstallments = `-- name: ListPicuinhaCaseInstallments :many
SELECT picuinha_case_installment_id, picuinha_case_id, installment_number, due_date,
  amount, extra_amount, is_paid, paid_at
FROM picuinha_case_installments
WHERE picuinha_case_id = $1
ORDER BY due_date ASC, installment_number ASC
`

func (q *Queries) ListPicuinhaCaseInstallments(ctx context.Context, picuinhaCaseID int32) ([]PicuinhaCaseInstallment, error) {
	rows, err := q.db.Query(ctx, listPicuinhaCaseInstallments, picuinhaCaseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PicuinhaCaseInstallment
	for rows.Next() {
		var i PicuinhaCaseInstallment
		if err := rows.Scan(
			&i.PicuinhaCaseInstallmentID,
			&i.PicuinhaCaseID,
			&i.InstallmentNumber,
			&i.DueDate,
			&i.Amount,
			&i.ExtraAmount,
			&i.IsPaid,
			&i.PaidAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPicuinhaCasesByPerson = `-- name: ListPicuinhaCasesByPerson :many
SELECT
  c.picuinha_case_id,
  c.person_id,
  c.title,
  c.case_type,
  c.total_amount,
  c.installment_count,
  c.installment_amount,
  c.start_date,
  c.payment_method_id,
  c.installment_plan_id,
  c.category_id,
  c.interest_rate,
  c.interest_rate_unit,
  c.recurrence_interval_months,
  c.created_at,
  COUNT(i.picuinha_case_installment_id) AS installments_total,
  COUNT(i.picuinha_case_installment_id) FILTER (WHERE i.is_paid) AS installments_paid,
  COALESCE(SUM(i.amount + i.extra_amount) FILTER (WHERE i.is_paid), 0)::decimal AS amount_paid,
  COALESCE(SUM(i.amount + i.extra_amount) FILTER (WHERE NOT i.is_paid), 0)::decimal AS amount_remaining
FROM picuinha_cases c
LEFT JOIN picuinha_case_installments i ON i.picuinha_case_id = c.picuinha_case_id
WHERE c.person_id = $1
GROUP BY c.picuinha_case_id
ORDER BY c.created_at DESC
`

type ListPicuinhaCasesByPersonRow struct {
	PicuinhaCaseID           int32
	PersonID                 int32
	Title                    string
	CaseType                 string
	TotalAmount              pgtype.Numeric
	InstallmentCount         pgtype.Int4
	InstallmentAmount        pgtype.Numeric
	StartDate                pgtype.Date
	PaymentMethodID          pgtype.Int4
	InstallmentPlanID        pgtype.Int4
	CategoryID               pgtype.Int4
	InterestRate             pgtype.Numeric
	InterestRateUnit         pgtype.Text
	RecurrenceIntervalMonths pgtype.Int4
	CreatedAt                pgtype.Timestamp
	InstallmentsTotal        int64
	InstallmentsPaid         int64
	AmountPaid               pgtype.Numeric
	AmountRemaining          pgtype.Numeric
}

func (q *Queries) ListPicuinhaCasesByPerson(ctx context.Context, personID int32) ([]ListPicuinhaCasesByPersonRow, error) {
	rows, err := q.db.Query(ctx, listPicuinhaCasesByPerson, personID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPicuinhaCasesByPersonRow
	for rows.Next() {
		var i ListPicuinhaCasesByPersonRow
		if err := rows.Scan(
			&i.PicuinhaCaseID,
			&i.PersonID,
			&i.Title,
			&i.CaseType,
			&i.TotalAmount,
			&i.InstallmentCount,
			&i.InstallmentAmount,
			&i.StartDate,
			&i.PaymentMethodID,
			&i.InstallmentPlanID,
			&i.CategoryID,
			&i.InterestRate,
			&i.InterestRateUnit,
			&i.RecurrenceIntervalMonths,
			&i.CreatedAt,
			&i.InstallmentsTotal,
			&i.InstallmentsPaid,
			&i.AmountPaid,
			&i.AmountRemaining,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePerson = `-- name: UpdatePerson :one
UPDATE picuinha_persons
SET name = $2,
    notes = $3
WHERE person_id = $1
RETURNING person_id, name, notes
`

type UpdatePersonParams struct {
	PersonID int32
	Name     string
	Notes    pgtype.Text
}

func (q *Queries) UpdatePerson(ctx context.Context, arg UpdatePersonParams) (PicuinhaPerson, error) {
	row := q.db.QueryRow(ctx, updatePerson, arg.PersonID, arg.Name, arg.Notes)
	var i PicuinhaPerson
	err := row.Scan(&i.PersonID, &i.Name, &i.Notes)
	return i, err
}

const updatePicuinhaCase = `-- name: UpdatePicuinhaCase :one
UPDATE picuinha_cases
SET person_id = $2,
    title = $3,
    case_type = $4,
    total_amount = $5,
    installment_count = $6,
    installment_amount = $7,
    start_date = $8,
    payment_method_id = $9,
    installment_plan_id = $10,
    category_id = $11,
    interest_rate = $12,
    interest_rate_unit = $13,
    recurrence_interval_months = $14
WHERE picuinha_case_id = $1
RETURNING picuinha_case_id, person_id, title, case_type, total_amount, installment_count, installment_amount,
  start_date, payment_method_id, installment_plan_id, category_id, interest_rate, interest_rate_unit,
  recurrence_interval_months, created_at
`

type UpdatePicuinhaCaseParams struct {
	PicuinhaCaseID           int32
	PersonID                 int32
	Title                    string
	CaseType                 string
	TotalAmount              pgtype.Numeric
	InstallmentCount         pgtype.Int4
	InstallmentAmount        pgtype.Numeric
	StartDate                pgtype.Date
	PaymentMethodID          pgtype.Int4
	InstallmentPlanID        pgtype.Int4
	CategoryID               pgtype.Int4
	InterestRate             pgtype.Numeric
	InterestRateUnit         pgtype.Text
	RecurrenceIntervalMonths pgtype.Int4
}

func (q *Queries) UpdatePicuinhaCase(ctx context.Context, arg UpdatePicuinhaCaseParams) (PicuinhaCase, error) {
	row := q.db.QueryRow(ctx, updatePicuinhaCase,
		arg.PicuinhaCaseID,
		arg.PersonID,
		arg.Title,
		arg.CaseType,
		arg.TotalAmount,
		arg.InstallmentCount,
		arg.InstallmentAmount,
		arg.StartDate,
		arg.PaymentMethodID,
		arg.InstallmentPlanID,
		arg.CategoryID,
		arg.InterestRate,
		arg.InterestRateUnit,
		arg.RecurrenceIntervalMonths,
	)
	var i PicuinhaCase
	err := row.Scan(
		&i.PicuinhaCaseID,
		&i.PersonID,
		&i.Title,
		&i.CaseType,
		&i.TotalAmount,
		&i.InstallmentCount,
		&i.InstallmentAmount,
		&i.StartDate,
		&i.PaymentMethodID,
		&i.InstallmentPlanID,
		&i.CategoryID,
		&i.InterestRate,
		&i.InterestRateUnit,
		&i.RecurrenceIntervalMonths,
		&i.CreatedAt,
	)
	return i, err
}

const updatePicuinhaCaseInstallment = `-- name: UpdatePicuinhaCaseInstallment :one
UPDATE picuinha_case_installments
SET amount = $2,
    extra_amount = $3,
    is_paid = $4,
    paid_at = $5
WHERE picuinha_case_installment_id = $1
RETURNING picuinha_case_installment_id, picuinha_case_id, installment_number, due_date,
  amount, extra_amount, is_paid, paid_at
`

type UpdatePicuinhaCaseInstallmentParams struct {
	PicuinhaCaseInstallmentID int32
	Amount                    pgtype.Numeric
	ExtraAmount               pgtype.Numeric
	IsPaid                    bool
	PaidAt                    pgtype.Timestamp
}

func (q *Queries) UpdatePicuinhaCaseInstallment(ctx context.Context, arg UpdatePicuinhaCaseInstallmentParams) (PicuinhaCaseInstallment, error) {
	row := q.db.QueryRow(ctx, updatePicuinhaCaseInstallment,
		arg.PicuinhaCaseInstallmentID,
		arg.Amount,
		arg.ExtraAmount,
		arg.IsPaid,
		arg.PaidAt,
	)
	var i PicuinhaCaseInstallment
	err := row.Scan(
		&i.PicuinhaCaseInstallmentID,
		&i.PicuinhaCaseID,
		&i.InstallmentNumber,
		&i.DueDate,
		&i.Amount,
		&i.ExtraAmount,
		&i.IsPaid,
		&i.PaidAt,
	)
	return i, err
}

const updatePicuinhaEntry = `-- name: UpdatePicuinhaEntry :one
UPDATE picuinha_entries
SET person_id = $2,
    kind = $3,
    amount = $4,
    cash_flow_id = $5,
    payment_method_id = $6,
    card_owner = $7
WHERE picuinha_entry_id = $1
RETURNING picuinha_entry_id, person_id, date, kind, amount, cash_flow_id, payment_method_id, card_owner
`

type UpdatePicuinhaEntryParams struct {
	PicuinhaEntryID int32
	PersonID        int32
	Kind            string
	Amount          pgtype.Numeric
	CashFlowID      pgtype.Int4
	PaymentMethodID pgtype.Int4
	CardOwner       string
}

func (q *Queries) UpdatePicuinhaEntry(ctx context.Context, arg UpdatePicuinhaEntryParams) (PicuinhaEntry, error) {
	row := q.db.QueryRow(ctx, updatePicuinhaEntry,
		arg.PicuinhaEntryID,
		arg.PersonID,
		arg.Kind,
		arg.Amount,
		arg.CashFlowID,
		arg.PaymentMethodID,
		arg.CardOwner,
	)
	var i PicuinhaEntry
	err := row.Scan(
		&i.PicuinhaEntryID,
		&i.PersonID,
		&i.Date,
		&i.Kind,
		&i.Amount,
		&i.CashFlowID,
		&i.PaymentMethodID,
		&i.CardOwner,
	)
	return i, err
}
